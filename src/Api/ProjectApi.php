<?php
/**
 * ProjectApi
 * PHP version 7.4
 *
 * @category Class
 * @package  SmartCat
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Smartcat API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SmartCat\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use SmartCat\ApiException;
use SmartCat\Configuration;
use SmartCat\HeaderSelector;
use SmartCat\ObjectSerializer;

/**
 * ProjectApi Class Doc Comment
 *
 * @category Class
 * @package  SmartCat
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProjectApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'apiIntegrationV1ProjectCancelPost' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectCompletePost' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectCopyingTaskIdGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectCreatePost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectDocumentPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectImportResultImportIdGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectLanguageDelete' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectLanguagePost' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectListGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdAssignPost' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdCopyingPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdDelete' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdGlossariesGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdGlossariesPut' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdManagersDelete' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdManagersPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdMtAvailableGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdMtGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdMtPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdPretranslationRulesGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdPretranslationRulesPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdPretranslationRulesPut' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdPut' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdReferenceFilesPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdStatisticsBuildPost' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdStatisticsGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectProjectIdTranslationmemoriesGet' => [
            'application/json',
        ],
        'apiIntegrationV1ProjectProjectIdTranslationmemoriesPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV1ProjectRestorePost' => [
            'application/json',
        ],
        'apiIntegrationV2ProjectListGet' => [
            'application/json',
        ],
        'apiIntegrationV2ProjectProjectIdExportPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV2ProjectProjectIdImportPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiIntegrationV2ProjectProjectIdStatisticsGet' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiIntegrationV1ProjectCancelPost
     *
     * Cancel the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCancelPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectCancelPost($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCancelPost'][0])
    {
        $this->apiIntegrationV1ProjectCancelPostWithHttpInfo($projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectCancelPostWithHttpInfo
     *
     * Cancel the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCancelPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectCancelPostWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCancelPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectCancelPostRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectCancelPostAsync
     *
     * Cancel the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCancelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectCancelPostAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCancelPost'][0])
    {
        return $this->apiIntegrationV1ProjectCancelPostAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectCancelPostAsyncWithHttpInfo
     *
     * Cancel the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCancelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectCancelPostAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCancelPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectCancelPostRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectCancelPost'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCancelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectCancelPostRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCancelPost'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectCancelPost'
            );
        }


        $resourcePath = '/api/integration/v1/project/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectId,
            'projectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectCompletePost
     *
     * Complete the workflow for all project documents. As a result, the project status will change to Completed.
     *
     * @param  string $projectId projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCompletePost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectCompletePost($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCompletePost'][0])
    {
        $this->apiIntegrationV1ProjectCompletePostWithHttpInfo($projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectCompletePostWithHttpInfo
     *
     * Complete the workflow for all project documents. As a result, the project status will change to Completed.
     *
     * @param  string $projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCompletePost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectCompletePostWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCompletePost'][0])
    {
        $request = $this->apiIntegrationV1ProjectCompletePostRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectCompletePostAsync
     *
     * Complete the workflow for all project documents. As a result, the project status will change to Completed.
     *
     * @param  string $projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCompletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectCompletePostAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCompletePost'][0])
    {
        return $this->apiIntegrationV1ProjectCompletePostAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectCompletePostAsyncWithHttpInfo
     *
     * Complete the workflow for all project documents. As a result, the project status will change to Completed.
     *
     * @param  string $projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCompletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectCompletePostAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCompletePost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectCompletePostRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectCompletePost'
     *
     * @param  string $projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCompletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectCompletePostRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCompletePost'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectCompletePost'
            );
        }


        $resourcePath = '/api/integration/v1/project/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectId,
            'projectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectCopyingTaskIdGet
     *
     * Get project copy state
     *
     * @param  string $taskId Copy task ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ProjectCopyStateModel
     */
    public function apiIntegrationV1ProjectCopyingTaskIdGet($taskId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectCopyingTaskIdGetWithHttpInfo($taskId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectCopyingTaskIdGetWithHttpInfo
     *
     * Get project copy state
     *
     * @param  string $taskId Copy task ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ProjectCopyStateModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectCopyingTaskIdGetWithHttpInfo($taskId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectCopyingTaskIdGetRequest($taskId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ProjectCopyStateModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ProjectCopyStateModel' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ProjectCopyStateModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ProjectCopyStateModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ProjectCopyStateModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectCopyingTaskIdGetAsync
     *
     * Get project copy state
     *
     * @param  string $taskId Copy task ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectCopyingTaskIdGetAsync($taskId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'][0])
    {
        return $this->apiIntegrationV1ProjectCopyingTaskIdGetAsyncWithHttpInfo($taskId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectCopyingTaskIdGetAsyncWithHttpInfo
     *
     * Get project copy state
     *
     * @param  string $taskId Copy task ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectCopyingTaskIdGetAsyncWithHttpInfo($taskId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'][0])
    {
        $returnType = '\SmartCat\Model\ProjectCopyStateModel';
        $request = $this->apiIntegrationV1ProjectCopyingTaskIdGetRequest($taskId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectCopyingTaskIdGet'
     *
     * @param  string $taskId Copy task ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectCopyingTaskIdGetRequest($taskId, string $contentType = self::contentTypes['apiIntegrationV1ProjectCopyingTaskIdGet'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling apiIntegrationV1ProjectCopyingTaskIdGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/copying/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectCreatePost
     *
     * Create the project
     *
     * @param  \SmartCat\Model\ModelWithFilesCreateProjectModel $modelWithFilesCreateProjectModel Project with files creation model (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCreatePost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ProjectModel
     */
    public function apiIntegrationV1ProjectCreatePost($modelWithFilesCreateProjectModel, string $contentType = self::contentTypes['apiIntegrationV1ProjectCreatePost'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectCreatePostWithHttpInfo($modelWithFilesCreateProjectModel, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectCreatePostWithHttpInfo
     *
     * Create the project
     *
     * @param  \SmartCat\Model\ModelWithFilesCreateProjectModel $modelWithFilesCreateProjectModel Project with files creation model (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCreatePost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ProjectModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectCreatePostWithHttpInfo($modelWithFilesCreateProjectModel, string $contentType = self::contentTypes['apiIntegrationV1ProjectCreatePost'][0])
    {
        $request = $this->apiIntegrationV1ProjectCreatePostRequest($modelWithFilesCreateProjectModel, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ProjectModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ProjectModel' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ProjectModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ProjectModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ProjectModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectCreatePostAsync
     *
     * Create the project
     *
     * @param  \SmartCat\Model\ModelWithFilesCreateProjectModel $modelWithFilesCreateProjectModel Project with files creation model (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCreatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectCreatePostAsync($modelWithFilesCreateProjectModel, string $contentType = self::contentTypes['apiIntegrationV1ProjectCreatePost'][0])
    {
        return $this->apiIntegrationV1ProjectCreatePostAsyncWithHttpInfo($modelWithFilesCreateProjectModel, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectCreatePostAsyncWithHttpInfo
     *
     * Create the project
     *
     * @param  \SmartCat\Model\ModelWithFilesCreateProjectModel $modelWithFilesCreateProjectModel Project with files creation model (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCreatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectCreatePostAsyncWithHttpInfo($modelWithFilesCreateProjectModel, string $contentType = self::contentTypes['apiIntegrationV1ProjectCreatePost'][0])
    {
        $returnType = '\SmartCat\Model\ProjectModel';
        $request = $this->apiIntegrationV1ProjectCreatePostRequest($modelWithFilesCreateProjectModel, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectCreatePost'
     *
     * @param  \SmartCat\Model\ModelWithFilesCreateProjectModel $modelWithFilesCreateProjectModel Project with files creation model (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectCreatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectCreatePostRequest($modelWithFilesCreateProjectModel, string $contentType = self::contentTypes['apiIntegrationV1ProjectCreatePost'][0])
    {

        // verify the required parameter 'modelWithFilesCreateProjectModel' is set
        if ($modelWithFilesCreateProjectModel === null || (is_array($modelWithFilesCreateProjectModel) && count($modelWithFilesCreateProjectModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelWithFilesCreateProjectModel when calling apiIntegrationV1ProjectCreatePost'
            );
        }


        $resourcePath = '/api/integration/v1/project/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modelWithFilesCreateProjectModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modelWithFilesCreateProjectModel));
            } else {
                $httpBody = $modelWithFilesCreateProjectModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectDocumentPost
     *
     * Add a document to the project
     *
     * @param  \SmartCat\Model\ModelWithFilesIReadOnlyList1 $modelWithFilesIReadOnlyList1 Document file upload model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $disassembleAlgorithmName Optional algorithm of file disassembly (optional)
     * @param  string $externalId External identifier assigned by the client upon the document creation (optional)
     * @param  string $metaInfo Additional user information about the document (optional)
     * @param  string $targetLanguages Comma-separated target languages of all documents. Optional parameter. Can be modified per document in the request body. By default, lists the project target languages. (optional)
     * @param  string $presetDisassembleAlgorithm Optional preset for the file disassembly algorithm (optional)
     * @param  bool $enableOcr Optional parameter for disabling OCR (the default is true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectDocumentPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\DocumentModel[]
     */
    public function apiIntegrationV1ProjectDocumentPost($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName = null, $externalId = null, $metaInfo = null, $targetLanguages = null, $presetDisassembleAlgorithm = null, $enableOcr = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectDocumentPost'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectDocumentPostWithHttpInfo($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName, $externalId, $metaInfo, $targetLanguages, $presetDisassembleAlgorithm, $enableOcr, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectDocumentPostWithHttpInfo
     *
     * Add a document to the project
     *
     * @param  \SmartCat\Model\ModelWithFilesIReadOnlyList1 $modelWithFilesIReadOnlyList1 Document file upload model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $disassembleAlgorithmName Optional algorithm of file disassembly (optional)
     * @param  string $externalId External identifier assigned by the client upon the document creation (optional)
     * @param  string $metaInfo Additional user information about the document (optional)
     * @param  string $targetLanguages Comma-separated target languages of all documents. Optional parameter. Can be modified per document in the request body. By default, lists the project target languages. (optional)
     * @param  string $presetDisassembleAlgorithm Optional preset for the file disassembly algorithm (optional)
     * @param  bool $enableOcr Optional parameter for disabling OCR (the default is true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectDocumentPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\DocumentModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectDocumentPostWithHttpInfo($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName = null, $externalId = null, $metaInfo = null, $targetLanguages = null, $presetDisassembleAlgorithm = null, $enableOcr = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectDocumentPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectDocumentPostRequest($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName, $externalId, $metaInfo, $targetLanguages, $presetDisassembleAlgorithm, $enableOcr, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\DocumentModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\DocumentModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\DocumentModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\DocumentModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\DocumentModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectDocumentPostAsync
     *
     * Add a document to the project
     *
     * @param  \SmartCat\Model\ModelWithFilesIReadOnlyList1 $modelWithFilesIReadOnlyList1 Document file upload model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $disassembleAlgorithmName Optional algorithm of file disassembly (optional)
     * @param  string $externalId External identifier assigned by the client upon the document creation (optional)
     * @param  string $metaInfo Additional user information about the document (optional)
     * @param  string $targetLanguages Comma-separated target languages of all documents. Optional parameter. Can be modified per document in the request body. By default, lists the project target languages. (optional)
     * @param  string $presetDisassembleAlgorithm Optional preset for the file disassembly algorithm (optional)
     * @param  bool $enableOcr Optional parameter for disabling OCR (the default is true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectDocumentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectDocumentPostAsync($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName = null, $externalId = null, $metaInfo = null, $targetLanguages = null, $presetDisassembleAlgorithm = null, $enableOcr = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectDocumentPost'][0])
    {
        return $this->apiIntegrationV1ProjectDocumentPostAsyncWithHttpInfo($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName, $externalId, $metaInfo, $targetLanguages, $presetDisassembleAlgorithm, $enableOcr, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectDocumentPostAsyncWithHttpInfo
     *
     * Add a document to the project
     *
     * @param  \SmartCat\Model\ModelWithFilesIReadOnlyList1 $modelWithFilesIReadOnlyList1 Document file upload model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $disassembleAlgorithmName Optional algorithm of file disassembly (optional)
     * @param  string $externalId External identifier assigned by the client upon the document creation (optional)
     * @param  string $metaInfo Additional user information about the document (optional)
     * @param  string $targetLanguages Comma-separated target languages of all documents. Optional parameter. Can be modified per document in the request body. By default, lists the project target languages. (optional)
     * @param  string $presetDisassembleAlgorithm Optional preset for the file disassembly algorithm (optional)
     * @param  bool $enableOcr Optional parameter for disabling OCR (the default is true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectDocumentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectDocumentPostAsyncWithHttpInfo($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName = null, $externalId = null, $metaInfo = null, $targetLanguages = null, $presetDisassembleAlgorithm = null, $enableOcr = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectDocumentPost'][0])
    {
        $returnType = '\SmartCat\Model\DocumentModel[]';
        $request = $this->apiIntegrationV1ProjectDocumentPostRequest($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName, $externalId, $metaInfo, $targetLanguages, $presetDisassembleAlgorithm, $enableOcr, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectDocumentPost'
     *
     * @param  \SmartCat\Model\ModelWithFilesIReadOnlyList1 $modelWithFilesIReadOnlyList1 Document file upload model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $disassembleAlgorithmName Optional algorithm of file disassembly (optional)
     * @param  string $externalId External identifier assigned by the client upon the document creation (optional)
     * @param  string $metaInfo Additional user information about the document (optional)
     * @param  string $targetLanguages Comma-separated target languages of all documents. Optional parameter. Can be modified per document in the request body. By default, lists the project target languages. (optional)
     * @param  string $presetDisassembleAlgorithm Optional preset for the file disassembly algorithm (optional)
     * @param  bool $enableOcr Optional parameter for disabling OCR (the default is true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectDocumentPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectDocumentPostRequest($modelWithFilesIReadOnlyList1, $projectId, $disassembleAlgorithmName = null, $externalId = null, $metaInfo = null, $targetLanguages = null, $presetDisassembleAlgorithm = null, $enableOcr = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectDocumentPost'][0])
    {

        // verify the required parameter 'modelWithFilesIReadOnlyList1' is set
        if ($modelWithFilesIReadOnlyList1 === null || (is_array($modelWithFilesIReadOnlyList1) && count($modelWithFilesIReadOnlyList1) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modelWithFilesIReadOnlyList1 when calling apiIntegrationV1ProjectDocumentPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectDocumentPost'
            );
        }








        $resourcePath = '/api/integration/v1/project/document';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectId,
            'projectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disassembleAlgorithmName,
            'disassembleAlgorithmName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $externalId,
            'externalId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $metaInfo,
            'metaInfo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $targetLanguages,
            'targetLanguages', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $presetDisassembleAlgorithm,
            'presetDisassembleAlgorithm', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enableOcr,
            'enableOcr', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modelWithFilesIReadOnlyList1)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modelWithFilesIReadOnlyList1));
            } else {
                $httpBody = $modelWithFilesIReadOnlyList1;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectImportResultImportIdGet
     *
     * Fetch the result of import into the Localization Project
     *
     * @param  string $importId Import task identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\StringsTableImportResult
     */
    public function apiIntegrationV1ProjectImportResultImportIdGet($importId, string $contentType = self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectImportResultImportIdGetWithHttpInfo($importId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectImportResultImportIdGetWithHttpInfo
     *
     * Fetch the result of import into the Localization Project
     *
     * @param  string $importId Import task identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\StringsTableImportResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectImportResultImportIdGetWithHttpInfo($importId, string $contentType = self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectImportResultImportIdGetRequest($importId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\StringsTableImportResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\StringsTableImportResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\StringsTableImportResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\StringsTableImportResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\StringsTableImportResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectImportResultImportIdGetAsync
     *
     * Fetch the result of import into the Localization Project
     *
     * @param  string $importId Import task identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectImportResultImportIdGetAsync($importId, string $contentType = self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'][0])
    {
        return $this->apiIntegrationV1ProjectImportResultImportIdGetAsyncWithHttpInfo($importId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectImportResultImportIdGetAsyncWithHttpInfo
     *
     * Fetch the result of import into the Localization Project
     *
     * @param  string $importId Import task identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectImportResultImportIdGetAsyncWithHttpInfo($importId, string $contentType = self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'][0])
    {
        $returnType = '\SmartCat\Model\StringsTableImportResult';
        $request = $this->apiIntegrationV1ProjectImportResultImportIdGetRequest($importId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectImportResultImportIdGet'
     *
     * @param  string $importId Import task identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectImportResultImportIdGetRequest($importId, string $contentType = self::contentTypes['apiIntegrationV1ProjectImportResultImportIdGet'][0])
    {

        // verify the required parameter 'importId' is set
        if ($importId === null || (is_array($importId) && count($importId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $importId when calling apiIntegrationV1ProjectImportResultImportIdGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/import-result/{importId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($importId !== null) {
            $resourcePath = str_replace(
                '{' . 'importId' . '}',
                ObjectSerializer::toPathValue($importId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectLanguageDelete
     *
     * Remove a target language from the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguageDelete'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectLanguageDelete($projectId, $targetLanguage, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguageDelete'][0])
    {
        $this->apiIntegrationV1ProjectLanguageDeleteWithHttpInfo($projectId, $targetLanguage, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectLanguageDeleteWithHttpInfo
     *
     * Remove a target language from the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguageDelete'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectLanguageDeleteWithHttpInfo($projectId, $targetLanguage, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguageDelete'][0])
    {
        $request = $this->apiIntegrationV1ProjectLanguageDeleteRequest($projectId, $targetLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectLanguageDeleteAsync
     *
     * Remove a target language from the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectLanguageDeleteAsync($projectId, $targetLanguage, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguageDelete'][0])
    {
        return $this->apiIntegrationV1ProjectLanguageDeleteAsyncWithHttpInfo($projectId, $targetLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectLanguageDeleteAsyncWithHttpInfo
     *
     * Remove a target language from the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectLanguageDeleteAsyncWithHttpInfo($projectId, $targetLanguage, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguageDelete'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectLanguageDeleteRequest($projectId, $targetLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectLanguageDelete'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectLanguageDeleteRequest($projectId, $targetLanguage, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguageDelete'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectLanguageDelete'
            );
        }

        // verify the required parameter 'targetLanguage' is set
        if ($targetLanguage === null || (is_array($targetLanguage) && count($targetLanguage) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $targetLanguage when calling apiIntegrationV1ProjectLanguageDelete'
            );
        }


        $resourcePath = '/api/integration/v1/project/language';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectId,
            'projectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $targetLanguage,
            'targetLanguage', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectLanguagePost
     *
     * Add a new target language to the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  bool $addLanguageToDocuments An optional parameter that can be used to disable the addition of a language for all project documents (by default - true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguagePost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectLanguagePost($projectId, $targetLanguage, $addLanguageToDocuments = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguagePost'][0])
    {
        $this->apiIntegrationV1ProjectLanguagePostWithHttpInfo($projectId, $targetLanguage, $addLanguageToDocuments, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectLanguagePostWithHttpInfo
     *
     * Add a new target language to the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  bool $addLanguageToDocuments An optional parameter that can be used to disable the addition of a language for all project documents (by default - true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguagePost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectLanguagePostWithHttpInfo($projectId, $targetLanguage, $addLanguageToDocuments = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguagePost'][0])
    {
        $request = $this->apiIntegrationV1ProjectLanguagePostRequest($projectId, $targetLanguage, $addLanguageToDocuments, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectLanguagePostAsync
     *
     * Add a new target language to the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  bool $addLanguageToDocuments An optional parameter that can be used to disable the addition of a language for all project documents (by default - true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectLanguagePostAsync($projectId, $targetLanguage, $addLanguageToDocuments = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguagePost'][0])
    {
        return $this->apiIntegrationV1ProjectLanguagePostAsyncWithHttpInfo($projectId, $targetLanguage, $addLanguageToDocuments, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectLanguagePostAsyncWithHttpInfo
     *
     * Add a new target language to the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  bool $addLanguageToDocuments An optional parameter that can be used to disable the addition of a language for all project documents (by default - true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectLanguagePostAsyncWithHttpInfo($projectId, $targetLanguage, $addLanguageToDocuments = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguagePost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectLanguagePostRequest($projectId, $targetLanguage, $addLanguageToDocuments, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectLanguagePost'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $targetLanguage Target language (required)
     * @param  bool $addLanguageToDocuments An optional parameter that can be used to disable the addition of a language for all project documents (by default - true) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectLanguagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectLanguagePostRequest($projectId, $targetLanguage, $addLanguageToDocuments = true, string $contentType = self::contentTypes['apiIntegrationV1ProjectLanguagePost'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectLanguagePost'
            );
        }

        // verify the required parameter 'targetLanguage' is set
        if ($targetLanguage === null || (is_array($targetLanguage) && count($targetLanguage) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $targetLanguage when calling apiIntegrationV1ProjectLanguagePost'
            );
        }



        $resourcePath = '/api/integration/v1/project/language';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectId,
            'projectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $targetLanguage,
            'targetLanguage', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $addLanguageToDocuments,
            'addLanguageToDocuments', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectListGet
     *
     * Fetch the list of account projects
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  ProjectTypeFilter $projectType Type of the project (optional)
     * @param  string[] $clientIds Comma-separated client IDs (optional)
     * @param  bool $includeDocuments Include project documents in response (optional, default to true)
     * @param  bool $includeQuotes Include project related quotes in response (optional, default to true)
     * @param  bool $includeCustomFields Include project related custom fields in response (optional, default to true)
     * @param  bool $includeClients Include project clients in response (optional, default to true)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectListGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ProjectModel[]
     */
    public function apiIntegrationV1ProjectListGet($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $projectType = null, $clientIds = null, $includeDocuments = true, $includeQuotes = true, $includeCustomFields = true, $includeClients = true, $offset = 0, $limit = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectListGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectListGetWithHttpInfo($createdByUserId, $assignedToUserId, $projectName, $externalTag, $projectType, $clientIds, $includeDocuments, $includeQuotes, $includeCustomFields, $includeClients, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectListGetWithHttpInfo
     *
     * Fetch the list of account projects
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  ProjectTypeFilter $projectType Type of the project (optional)
     * @param  string[] $clientIds Comma-separated client IDs (optional)
     * @param  bool $includeDocuments Include project documents in response (optional, default to true)
     * @param  bool $includeQuotes Include project related quotes in response (optional, default to true)
     * @param  bool $includeCustomFields Include project related custom fields in response (optional, default to true)
     * @param  bool $includeClients Include project clients in response (optional, default to true)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectListGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ProjectModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectListGetWithHttpInfo($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $projectType = null, $clientIds = null, $includeDocuments = true, $includeQuotes = true, $includeCustomFields = true, $includeClients = true, $offset = 0, $limit = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectListGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectListGetRequest($createdByUserId, $assignedToUserId, $projectName, $externalTag, $projectType, $clientIds, $includeDocuments, $includeQuotes, $includeCustomFields, $includeClients, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ProjectModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ProjectModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ProjectModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ProjectModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ProjectModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectListGetAsync
     *
     * Fetch the list of account projects
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  ProjectTypeFilter $projectType Type of the project (optional)
     * @param  string[] $clientIds Comma-separated client IDs (optional)
     * @param  bool $includeDocuments Include project documents in response (optional, default to true)
     * @param  bool $includeQuotes Include project related quotes in response (optional, default to true)
     * @param  bool $includeCustomFields Include project related custom fields in response (optional, default to true)
     * @param  bool $includeClients Include project clients in response (optional, default to true)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectListGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectListGetAsync($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $projectType = null, $clientIds = null, $includeDocuments = true, $includeQuotes = true, $includeCustomFields = true, $includeClients = true, $offset = 0, $limit = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectListGet'][0])
    {
        return $this->apiIntegrationV1ProjectListGetAsyncWithHttpInfo($createdByUserId, $assignedToUserId, $projectName, $externalTag, $projectType, $clientIds, $includeDocuments, $includeQuotes, $includeCustomFields, $includeClients, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectListGetAsyncWithHttpInfo
     *
     * Fetch the list of account projects
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  ProjectTypeFilter $projectType Type of the project (optional)
     * @param  string[] $clientIds Comma-separated client IDs (optional)
     * @param  bool $includeDocuments Include project documents in response (optional, default to true)
     * @param  bool $includeQuotes Include project related quotes in response (optional, default to true)
     * @param  bool $includeCustomFields Include project related custom fields in response (optional, default to true)
     * @param  bool $includeClients Include project clients in response (optional, default to true)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectListGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectListGetAsyncWithHttpInfo($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $projectType = null, $clientIds = null, $includeDocuments = true, $includeQuotes = true, $includeCustomFields = true, $includeClients = true, $offset = 0, $limit = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectListGet'][0])
    {
        $returnType = '\SmartCat\Model\ProjectModel[]';
        $request = $this->apiIntegrationV1ProjectListGetRequest($createdByUserId, $assignedToUserId, $projectName, $externalTag, $projectType, $clientIds, $includeDocuments, $includeQuotes, $includeCustomFields, $includeClients, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectListGet'
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  ProjectTypeFilter $projectType Type of the project (optional)
     * @param  string[] $clientIds Comma-separated client IDs (optional)
     * @param  bool $includeDocuments Include project documents in response (optional, default to true)
     * @param  bool $includeQuotes Include project related quotes in response (optional, default to true)
     * @param  bool $includeCustomFields Include project related custom fields in response (optional, default to true)
     * @param  bool $includeClients Include project clients in response (optional, default to true)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectListGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectListGetRequest($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $projectType = null, $clientIds = null, $includeDocuments = true, $includeQuotes = true, $includeCustomFields = true, $includeClients = true, $offset = 0, $limit = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectListGet'][0])
    {














        $resourcePath = '/api/integration/v1/project/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $createdByUserId,
            'createdByUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assignedToUserId,
            'assignedToUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectName,
            'projectName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $externalTag,
            'externalTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectType,
            'projectType', // param base name
            'ProjectTypeFilter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clientIds,
            'clientIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeDocuments,
            'includeDocuments', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeQuotes,
            'includeQuotes', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeCustomFields,
            'includeCustomFields', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeClients,
            'includeClients', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdAssignPost
     *
     * Automatically assign all new documents/segments to current linguists
     *
     * @param  string $projectId Project ID (required)
     * @param  AutoAssignmentMode $mode Auto-assignment mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\WorkflowStageInDocumentModel[]
     */
    public function apiIntegrationV1ProjectProjectIdAssignPost($projectId, $mode = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdAssignPostWithHttpInfo($projectId, $mode, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdAssignPostWithHttpInfo
     *
     * Automatically assign all new documents/segments to current linguists
     *
     * @param  string $projectId Project ID (required)
     * @param  AutoAssignmentMode $mode Auto-assignment mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\WorkflowStageInDocumentModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdAssignPostWithHttpInfo($projectId, $mode = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdAssignPostRequest($projectId, $mode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\WorkflowStageInDocumentModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\WorkflowStageInDocumentModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\WorkflowStageInDocumentModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\WorkflowStageInDocumentModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\WorkflowStageInDocumentModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdAssignPostAsync
     *
     * Automatically assign all new documents/segments to current linguists
     *
     * @param  string $projectId Project ID (required)
     * @param  AutoAssignmentMode $mode Auto-assignment mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdAssignPostAsync($projectId, $mode = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdAssignPostAsyncWithHttpInfo($projectId, $mode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdAssignPostAsyncWithHttpInfo
     *
     * Automatically assign all new documents/segments to current linguists
     *
     * @param  string $projectId Project ID (required)
     * @param  AutoAssignmentMode $mode Auto-assignment mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdAssignPostAsyncWithHttpInfo($projectId, $mode = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'][0])
    {
        $returnType = '\SmartCat\Model\WorkflowStageInDocumentModel[]';
        $request = $this->apiIntegrationV1ProjectProjectIdAssignPostRequest($projectId, $mode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdAssignPost'
     *
     * @param  string $projectId Project ID (required)
     * @param  AutoAssignmentMode $mode Auto-assignment mode (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdAssignPostRequest($projectId, $mode = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdAssignPost'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdAssignPost'
            );
        }



        $resourcePath = '/api/integration/v1/project/{projectId}/assign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mode,
            'mode', // param base name
            'AutoAssignmentMode', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet
     *
     * Receive statistics for the completed parts of the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ExecutiveStatisticsModel[]
     */
    public function apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetWithHttpInfo
     *
     * Receive statistics for the completed parts of the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ExecutiveStatisticsModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ExecutiveStatisticsModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ExecutiveStatisticsModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ExecutiveStatisticsModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ExecutiveStatisticsModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ExecutiveStatisticsModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetAsync
     *
     * Receive statistics for the completed parts of the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetAsyncWithHttpInfo
     *
     * Receive statistics for the completed parts of the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'][0])
    {
        $returnType = '\SmartCat\Model\ExecutiveStatisticsModel[]';
        $request = $this->apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGetRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdCompletedWorkStatisticsGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/completedWorkStatistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdCopyingPost
     *
     * Run copying a project
     *
     * @param  \SmartCat\Model\ProjectCopyModel $projectCopyModel projectCopyModel (required)
     * @param  string $projectId projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function apiIntegrationV1ProjectProjectIdCopyingPost($projectCopyModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdCopyingPostWithHttpInfo($projectCopyModel, $projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdCopyingPostWithHttpInfo
     *
     * Run copying a project
     *
     * @param  \SmartCat\Model\ProjectCopyModel $projectCopyModel (required)
     * @param  string $projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdCopyingPostWithHttpInfo($projectCopyModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdCopyingPostRequest($projectCopyModel, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdCopyingPostAsync
     *
     * Run copying a project
     *
     * @param  \SmartCat\Model\ProjectCopyModel $projectCopyModel (required)
     * @param  string $projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdCopyingPostAsync($projectCopyModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdCopyingPostAsyncWithHttpInfo($projectCopyModel, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdCopyingPostAsyncWithHttpInfo
     *
     * Run copying a project
     *
     * @param  \SmartCat\Model\ProjectCopyModel $projectCopyModel (required)
     * @param  string $projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdCopyingPostAsyncWithHttpInfo($projectCopyModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'][0])
    {
        $returnType = 'string';
        $request = $this->apiIntegrationV1ProjectProjectIdCopyingPostRequest($projectCopyModel, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdCopyingPost'
     *
     * @param  \SmartCat\Model\ProjectCopyModel $projectCopyModel (required)
     * @param  string $projectId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdCopyingPostRequest($projectCopyModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdCopyingPost'][0])
    {

        // verify the required parameter 'projectCopyModel' is set
        if ($projectCopyModel === null || (is_array($projectCopyModel) && count($projectCopyModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectCopyModel when calling apiIntegrationV1ProjectProjectIdCopyingPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdCopyingPost'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/copying';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($projectCopyModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($projectCopyModel));
            } else {
                $httpBody = $projectCopyModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdDelete
     *
     * Delete the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdDelete($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdDeleteWithHttpInfo($projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdDeleteWithHttpInfo
     *
     * Delete the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdDeleteWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdDeleteRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdDeleteAsync
     *
     * Delete the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdDeleteAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdDeleteAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdDeleteAsyncWithHttpInfo
     *
     * Delete the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdDeleteAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdDeleteRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdDelete'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdDeleteRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdDelete'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdDelete'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet
     *
     * Fetch the status of removing empty project folders
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\EmptyProjectFoldersRemoveTaskStatus
     */
    public function apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetWithHttpInfo
     *
     * Fetch the status of removing empty project folders
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\EmptyProjectFoldersRemoveTaskStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\EmptyProjectFoldersRemoveTaskStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\EmptyProjectFoldersRemoveTaskStatus' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\EmptyProjectFoldersRemoveTaskStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\EmptyProjectFoldersRemoveTaskStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\EmptyProjectFoldersRemoveTaskStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetAsync
     *
     * Fetch the status of removing empty project folders
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetAsyncWithHttpInfo
     *
     * Fetch the status of removing empty project folders
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'][0])
    {
        $returnType = '\SmartCat\Model\EmptyProjectFoldersRemoveTaskStatus';
        $request = $this->apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGetRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdEmptyFoldersRemovingStatusGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/empty-folders-removing-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut
     *
     * Enable or disable calculating fuzzy repetitions in the project statistics
     *
     * @param  string $projectId projectId (required)
     * @param  bool $withFuzzyMatches withFuzzyMatches (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut($projectId, $withFuzzyMatches = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutWithHttpInfo($projectId, $withFuzzyMatches, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutWithHttpInfo
     *
     * Enable or disable calculating fuzzy repetitions in the project statistics
     *
     * @param  string $projectId (required)
     * @param  bool $withFuzzyMatches (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutWithHttpInfo($projectId, $withFuzzyMatches = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutRequest($projectId, $withFuzzyMatches, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutAsync
     *
     * Enable or disable calculating fuzzy repetitions in the project statistics
     *
     * @param  string $projectId (required)
     * @param  bool $withFuzzyMatches (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutAsync($projectId, $withFuzzyMatches = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutAsyncWithHttpInfo($projectId, $withFuzzyMatches, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutAsyncWithHttpInfo
     *
     * Enable or disable calculating fuzzy repetitions in the project statistics
     *
     * @param  string $projectId (required)
     * @param  bool $withFuzzyMatches (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutAsyncWithHttpInfo($projectId, $withFuzzyMatches = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutRequest($projectId, $withFuzzyMatches, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'
     *
     * @param  string $projectId (required)
     * @param  bool $withFuzzyMatches (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPutRequest($projectId, $withFuzzyMatches = null, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdFuzzyRepetitionsPut'
            );
        }



        $resourcePath = '/api/integration/v1/project/{projectId}/fuzzyRepetitions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $withFuzzyMatches,
            'withFuzzyMatches', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGet
     *
     * Receive the project model
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ProjectModel
     */
    public function apiIntegrationV1ProjectProjectIdGet($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdGetWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGetWithHttpInfo
     *
     * Receive the project model
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ProjectModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdGetWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdGetRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ProjectModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ProjectModel' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ProjectModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ProjectModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ProjectModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGetAsync
     *
     * Receive the project model
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdGetAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdGetAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGetAsyncWithHttpInfo
     *
     * Receive the project model
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdGetAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGet'][0])
    {
        $returnType = '\SmartCat\Model\ProjectModel';
        $request = $this->apiIntegrationV1ProjectProjectIdGetRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdGetRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGlossariesGet
     *
     * Fetch the list of glossaries plugged into the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\GlossaryModel[]
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesGet($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdGlossariesGetWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGlossariesGetWithHttpInfo
     *
     * Fetch the list of glossaries plugged into the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\GlossaryModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesGetWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdGlossariesGetRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\GlossaryModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\GlossaryModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\GlossaryModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\GlossaryModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\GlossaryModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGlossariesGetAsync
     *
     * Fetch the list of glossaries plugged into the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesGetAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdGlossariesGetAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGlossariesGetAsyncWithHttpInfo
     *
     * Fetch the list of glossaries plugged into the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesGetAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'][0])
    {
        $returnType = '\SmartCat\Model\GlossaryModel[]';
        $request = $this->apiIntegrationV1ProjectProjectIdGlossariesGetRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdGlossariesGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesGetRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdGlossariesGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/glossaries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGlossariesPut
     *
     * Set a collection of glossaries plugged into the project
     *
     * @param  string[] $requestBody Array of glossary IDs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesPut($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdGlossariesPutWithHttpInfo($requestBody, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGlossariesPutWithHttpInfo
     *
     * Set a collection of glossaries plugged into the project
     *
     * @param  string[] $requestBody Array of glossary IDs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesPutWithHttpInfo($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdGlossariesPutRequest($requestBody, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGlossariesPutAsync
     *
     * Set a collection of glossaries plugged into the project
     *
     * @param  string[] $requestBody Array of glossary IDs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesPutAsync($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdGlossariesPutAsyncWithHttpInfo($requestBody, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdGlossariesPutAsyncWithHttpInfo
     *
     * Set a collection of glossaries plugged into the project
     *
     * @param  string[] $requestBody Array of glossary IDs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesPutAsyncWithHttpInfo($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdGlossariesPutRequest($requestBody, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdGlossariesPut'
     *
     * @param  string[] $requestBody Array of glossary IDs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdGlossariesPutRequest($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdGlossariesPut'][0])
    {

        // verify the required parameter 'requestBody' is set
        if ($requestBody === null || (is_array($requestBody) && count($requestBody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestBody when calling apiIntegrationV1ProjectProjectIdGlossariesPut'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdGlossariesPut'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/glossaries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requestBody));
            } else {
                $httpBody = $requestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdManagersDelete
     *
     * Delete managers from the project
     *
     * @param  string[] $requestBody List of IDs of users labeled as managers (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdManagersDelete($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdManagersDeleteWithHttpInfo($requestBody, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdManagersDeleteWithHttpInfo
     *
     * Delete managers from the project
     *
     * @param  string[] $requestBody List of IDs of users labeled as managers (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdManagersDeleteWithHttpInfo($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdManagersDeleteRequest($requestBody, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdManagersDeleteAsync
     *
     * Delete managers from the project
     *
     * @param  string[] $requestBody List of IDs of users labeled as managers (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdManagersDeleteAsync($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdManagersDeleteAsyncWithHttpInfo($requestBody, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdManagersDeleteAsyncWithHttpInfo
     *
     * Delete managers from the project
     *
     * @param  string[] $requestBody List of IDs of users labeled as managers (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdManagersDeleteAsyncWithHttpInfo($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdManagersDeleteRequest($requestBody, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdManagersDelete'
     *
     * @param  string[] $requestBody List of IDs of users labeled as managers (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdManagersDeleteRequest($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersDelete'][0])
    {

        // verify the required parameter 'requestBody' is set
        if ($requestBody === null || (is_array($requestBody) && count($requestBody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestBody when calling apiIntegrationV1ProjectProjectIdManagersDelete'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdManagersDelete'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/managers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requestBody));
            } else {
                $httpBody = $requestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdManagersPost
     *
     * Add managers to the specified project
     *
     * @param  string[] $requestBody User IDs list (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdManagersPost($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdManagersPostWithHttpInfo($requestBody, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdManagersPostWithHttpInfo
     *
     * Add managers to the specified project
     *
     * @param  string[] $requestBody User IDs list (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdManagersPostWithHttpInfo($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdManagersPostRequest($requestBody, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdManagersPostAsync
     *
     * Add managers to the specified project
     *
     * @param  string[] $requestBody User IDs list (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdManagersPostAsync($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdManagersPostAsyncWithHttpInfo($requestBody, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdManagersPostAsyncWithHttpInfo
     *
     * Add managers to the specified project
     *
     * @param  string[] $requestBody User IDs list (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdManagersPostAsyncWithHttpInfo($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdManagersPostRequest($requestBody, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdManagersPost'
     *
     * @param  string[] $requestBody User IDs list (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdManagersPostRequest($requestBody, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdManagersPost'][0])
    {

        // verify the required parameter 'requestBody' is set
        if ($requestBody === null || (is_array($requestBody) && count($requestBody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requestBody when calling apiIntegrationV1ProjectProjectIdManagersPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdManagersPost'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/managers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($requestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($requestBody));
            } else {
                $httpBody = $requestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtAvailableGet
     *
     * Fetch all the MT engines and profiles that can be used in the specified project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ProjectMTEngineSupportedLanguagesModel[]
     */
    public function apiIntegrationV1ProjectProjectIdMtAvailableGet($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdMtAvailableGetWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtAvailableGetWithHttpInfo
     *
     * Fetch all the MT engines and profiles that can be used in the specified project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ProjectMTEngineSupportedLanguagesModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdMtAvailableGetWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdMtAvailableGetRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ProjectMTEngineSupportedLanguagesModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ProjectMTEngineSupportedLanguagesModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ProjectMTEngineSupportedLanguagesModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ProjectMTEngineSupportedLanguagesModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ProjectMTEngineSupportedLanguagesModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtAvailableGetAsync
     *
     * Fetch all the MT engines and profiles that can be used in the specified project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdMtAvailableGetAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdMtAvailableGetAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtAvailableGetAsyncWithHttpInfo
     *
     * Fetch all the MT engines and profiles that can be used in the specified project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdMtAvailableGetAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'][0])
    {
        $returnType = '\SmartCat\Model\ProjectMTEngineSupportedLanguagesModel[]';
        $request = $this->apiIntegrationV1ProjectProjectIdMtAvailableGetRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdMtAvailableGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdMtAvailableGetRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtAvailableGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdMtAvailableGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/mt/available';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtGet
     *
     * Fetch the project&#39;s MT configuration
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ProjectMTEngineModel[]
     */
    public function apiIntegrationV1ProjectProjectIdMtGet($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdMtGetWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtGetWithHttpInfo
     *
     * Fetch the project&#39;s MT configuration
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ProjectMTEngineModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdMtGetWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdMtGetRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ProjectMTEngineModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ProjectMTEngineModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ProjectMTEngineModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ProjectMTEngineModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ProjectMTEngineModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtGetAsync
     *
     * Fetch the project&#39;s MT configuration
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdMtGetAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdMtGetAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtGetAsyncWithHttpInfo
     *
     * Fetch the project&#39;s MT configuration
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdMtGetAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'][0])
    {
        $returnType = '\SmartCat\Model\ProjectMTEngineModel[]';
        $request = $this->apiIntegrationV1ProjectProjectIdMtGetRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdMtGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdMtGetRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdMtGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/mt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtPost
     *
     * Set an MT configuration in the project
     *
     * @param  \SmartCat\Model\ProjectMTEngineModel[] $projectMTEngineModel Required MT settings (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdMtPost($projectMTEngineModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdMtPostWithHttpInfo($projectMTEngineModel, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtPostWithHttpInfo
     *
     * Set an MT configuration in the project
     *
     * @param  \SmartCat\Model\ProjectMTEngineModel[] $projectMTEngineModel Required MT settings (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdMtPostWithHttpInfo($projectMTEngineModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdMtPostRequest($projectMTEngineModel, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtPostAsync
     *
     * Set an MT configuration in the project
     *
     * @param  \SmartCat\Model\ProjectMTEngineModel[] $projectMTEngineModel Required MT settings (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdMtPostAsync($projectMTEngineModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdMtPostAsyncWithHttpInfo($projectMTEngineModel, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdMtPostAsyncWithHttpInfo
     *
     * Set an MT configuration in the project
     *
     * @param  \SmartCat\Model\ProjectMTEngineModel[] $projectMTEngineModel Required MT settings (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdMtPostAsyncWithHttpInfo($projectMTEngineModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdMtPostRequest($projectMTEngineModel, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdMtPost'
     *
     * @param  \SmartCat\Model\ProjectMTEngineModel[] $projectMTEngineModel Required MT settings (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdMtPostRequest($projectMTEngineModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdMtPost'][0])
    {

        // verify the required parameter 'projectMTEngineModel' is set
        if ($projectMTEngineModel === null || (is_array($projectMTEngineModel) && count($projectMTEngineModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectMTEngineModel when calling apiIntegrationV1ProjectProjectIdMtPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdMtPost'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/mt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($projectMTEngineModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($projectMTEngineModel));
            } else {
                $httpBody = $projectMTEngineModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesGet
     *
     * Fetch the project pre-processing rules
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\PretranslateRuleModel[]
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesGet($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdPretranslationRulesGetWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesGetWithHttpInfo
     *
     * Fetch the project pre-processing rules
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\PretranslateRuleModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesGetWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdPretranslationRulesGetRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\PretranslateRuleModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\PretranslateRuleModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\PretranslateRuleModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\PretranslateRuleModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\PretranslateRuleModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesGetAsync
     *
     * Fetch the project pre-processing rules
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesGetAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdPretranslationRulesGetAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesGetAsyncWithHttpInfo
     *
     * Fetch the project pre-processing rules
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesGetAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'][0])
    {
        $returnType = '\SmartCat\Model\PretranslateRuleModel[]';
        $request = $this->apiIntegrationV1ProjectProjectIdPretranslationRulesGetRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdPretranslationRulesGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesGetRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdPretranslationRulesGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/pretranslation-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesPost
     *
     * Define project pre-processing rules
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPost($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdPretranslationRulesPostWithHttpInfo($pretranslateRuleModel, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesPostWithHttpInfo
     *
     * Define project pre-processing rules
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPostWithHttpInfo($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdPretranslationRulesPostRequest($pretranslateRuleModel, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesPostAsync
     *
     * Define project pre-processing rules
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPostAsync($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdPretranslationRulesPostAsyncWithHttpInfo($pretranslateRuleModel, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesPostAsyncWithHttpInfo
     *
     * Define project pre-processing rules
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPostAsyncWithHttpInfo($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdPretranslationRulesPostRequest($pretranslateRuleModel, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdPretranslationRulesPost'
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPostRequest($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPost'][0])
    {

        // verify the required parameter 'pretranslateRuleModel' is set
        if ($pretranslateRuleModel === null || (is_array($pretranslateRuleModel) && count($pretranslateRuleModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pretranslateRuleModel when calling apiIntegrationV1ProjectProjectIdPretranslationRulesPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdPretranslationRulesPost'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/pretranslation-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pretranslateRuleModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pretranslateRuleModel));
            } else {
                $httpBody = $pretranslateRuleModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesPut
     *
     * Define project pre-processing rules
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPut($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdPretranslationRulesPutWithHttpInfo($pretranslateRuleModel, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesPutWithHttpInfo
     *
     * Define project pre-processing rules
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPutWithHttpInfo($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdPretranslationRulesPutRequest($pretranslateRuleModel, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesPutAsync
     *
     * Define project pre-processing rules
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPutAsync($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdPretranslationRulesPutAsyncWithHttpInfo($pretranslateRuleModel, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPretranslationRulesPutAsyncWithHttpInfo
     *
     * Define project pre-processing rules
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPutAsyncWithHttpInfo($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdPretranslationRulesPutRequest($pretranslateRuleModel, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdPretranslationRulesPut'
     *
     * @param  \SmartCat\Model\PretranslateRuleModel[] $pretranslateRuleModel Project pre-processing rules (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdPretranslationRulesPutRequest($pretranslateRuleModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPretranslationRulesPut'][0])
    {

        // verify the required parameter 'pretranslateRuleModel' is set
        if ($pretranslateRuleModel === null || (is_array($pretranslateRuleModel) && count($pretranslateRuleModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pretranslateRuleModel when calling apiIntegrationV1ProjectProjectIdPretranslationRulesPut'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdPretranslationRulesPut'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/pretranslation-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pretranslateRuleModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pretranslateRuleModel));
            } else {
                $httpBody = $pretranslateRuleModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPut
     *
     * Update a project by ID
     *
     * @param  \SmartCat\Model\ProjectChangesModel $projectChangesModel Project changes model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPut'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdPut($projectChangesModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPut'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdPutWithHttpInfo($projectChangesModel, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPutWithHttpInfo
     *
     * Update a project by ID
     *
     * @param  \SmartCat\Model\ProjectChangesModel $projectChangesModel Project changes model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPut'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdPutWithHttpInfo($projectChangesModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPut'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdPutRequest($projectChangesModel, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPutAsync
     *
     * Update a project by ID
     *
     * @param  \SmartCat\Model\ProjectChangesModel $projectChangesModel Project changes model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdPutAsync($projectChangesModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPut'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdPutAsyncWithHttpInfo($projectChangesModel, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdPutAsyncWithHttpInfo
     *
     * Update a project by ID
     *
     * @param  \SmartCat\Model\ProjectChangesModel $projectChangesModel Project changes model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdPutAsyncWithHttpInfo($projectChangesModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPut'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdPutRequest($projectChangesModel, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdPut'
     *
     * @param  \SmartCat\Model\ProjectChangesModel $projectChangesModel Project changes model (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdPutRequest($projectChangesModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdPut'][0])
    {

        // verify the required parameter 'projectChangesModel' is set
        if ($projectChangesModel === null || (is_array($projectChangesModel) && count($projectChangesModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectChangesModel when calling apiIntegrationV1ProjectProjectIdPut'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdPut'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($projectChangesModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($projectChangesModel));
            } else {
                $httpBody = $projectChangesModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdReferenceFilesPost
     *
     * Add reference files to a project
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files to be uploaded (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdReferenceFilesPost($uploadedFile, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdReferenceFilesPostWithHttpInfo($uploadedFile, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdReferenceFilesPostWithHttpInfo
     *
     * Add reference files to a project
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files to be uploaded (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdReferenceFilesPostWithHttpInfo($uploadedFile, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdReferenceFilesPostRequest($uploadedFile, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdReferenceFilesPostAsync
     *
     * Add reference files to a project
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files to be uploaded (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdReferenceFilesPostAsync($uploadedFile, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdReferenceFilesPostAsyncWithHttpInfo($uploadedFile, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdReferenceFilesPostAsyncWithHttpInfo
     *
     * Add reference files to a project
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files to be uploaded (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdReferenceFilesPostAsyncWithHttpInfo($uploadedFile, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdReferenceFilesPostRequest($uploadedFile, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdReferenceFilesPost'
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files to be uploaded (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdReferenceFilesPostRequest($uploadedFile, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdReferenceFilesPost'][0])
    {

        // verify the required parameter 'uploadedFile' is set
        if ($uploadedFile === null || (is_array($uploadedFile) && count($uploadedFile) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uploadedFile when calling apiIntegrationV1ProjectProjectIdReferenceFilesPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdReferenceFilesPost'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/ReferenceFiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($uploadedFile)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($uploadedFile));
            } else {
                $httpBody = $uploadedFile;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost
     *
     * Run the empty project folders deletion task
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostWithHttpInfo($projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostWithHttpInfo
     *
     * Run the empty project folders deletion task
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostAsync
     *
     * Run the empty project folders deletion task
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostAsyncWithHttpInfo
     *
     * Run the empty project folders deletion task
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPostRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdRunEmptyFoldersRemovingPost'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/run-empty-folders-removing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdStatisticsBuildPost
     *
     * Start processing the project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsBuildPost($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdStatisticsBuildPostWithHttpInfo($projectId, $onlyExactMatches, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdStatisticsBuildPostWithHttpInfo
     *
     * Start processing the project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsBuildPostWithHttpInfo($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdStatisticsBuildPostRequest($projectId, $onlyExactMatches, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdStatisticsBuildPostAsync
     *
     * Start processing the project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsBuildPostAsync($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdStatisticsBuildPostAsyncWithHttpInfo($projectId, $onlyExactMatches, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdStatisticsBuildPostAsyncWithHttpInfo
     *
     * Start processing the project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsBuildPostAsyncWithHttpInfo($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdStatisticsBuildPostRequest($projectId, $onlyExactMatches, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdStatisticsBuildPost'
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsBuildPostRequest($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsBuildPost'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdStatisticsBuildPost'
            );
        }



        $resourcePath = '/api/integration/v1/project/{projectId}/statistics/build';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onlyExactMatches,
            'onlyExactMatches', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdStatisticsGet
     *
     * (This method is obsolete and has been replaced with /api/integration/v2/project/{projectId}/statistics)  Fetch project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,\SmartCat\Model\ProjectStatisticsObsoleteModel>
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsGet($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdStatisticsGetWithHttpInfo($projectId, $onlyExactMatches, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdStatisticsGetWithHttpInfo
     *
     * (This method is obsolete and has been replaced with /api/integration/v2/project/{projectId}/statistics)  Fetch project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,\SmartCat\Model\ProjectStatisticsObsoleteModel>, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsGetWithHttpInfo($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdStatisticsGetRequest($projectId, $onlyExactMatches, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,\SmartCat\Model\ProjectStatisticsObsoleteModel>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,\SmartCat\Model\ProjectStatisticsObsoleteModel>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,\SmartCat\Model\ProjectStatisticsObsoleteModel>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,\SmartCat\Model\ProjectStatisticsObsoleteModel>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,\SmartCat\Model\ProjectStatisticsObsoleteModel>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdStatisticsGetAsync
     *
     * (This method is obsolete and has been replaced with /api/integration/v2/project/{projectId}/statistics)  Fetch project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsGetAsync($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdStatisticsGetAsyncWithHttpInfo($projectId, $onlyExactMatches, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdStatisticsGetAsyncWithHttpInfo
     *
     * (This method is obsolete and has been replaced with /api/integration/v2/project/{projectId}/statistics)  Fetch project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsGetAsyncWithHttpInfo($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'][0])
    {
        $returnType = 'array<string,\SmartCat\Model\ProjectStatisticsObsoleteModel>';
        $request = $this->apiIntegrationV1ProjectProjectIdStatisticsGetRequest($projectId, $onlyExactMatches, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdStatisticsGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdStatisticsGetRequest($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdStatisticsGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdStatisticsGet'
            );
        }



        $resourcePath = '/api/integration/v1/project/{projectId}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onlyExactMatches,
            'onlyExactMatches', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost
     *
     * Recreate the set of TMs plugged into the project.  A separate set of TMs is created for each target language.
     *
     * @param  \SmartCat\Model\TranslationMemoriesForLanguageModel[] $translationMemoriesForLanguageModel Collections of languages and their respective TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost($translationMemoriesForLanguageModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostWithHttpInfo($translationMemoriesForLanguageModel, $projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostWithHttpInfo
     *
     * Recreate the set of TMs plugged into the project.  A separate set of TMs is created for each target language.
     *
     * @param  \SmartCat\Model\TranslationMemoriesForLanguageModel[] $translationMemoriesForLanguageModel Collections of languages and their respective TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostWithHttpInfo($translationMemoriesForLanguageModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostRequest($translationMemoriesForLanguageModel, $projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostAsync
     *
     * Recreate the set of TMs plugged into the project.  A separate set of TMs is created for each target language.
     *
     * @param  \SmartCat\Model\TranslationMemoriesForLanguageModel[] $translationMemoriesForLanguageModel Collections of languages and their respective TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostAsync($translationMemoriesForLanguageModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostAsyncWithHttpInfo($translationMemoriesForLanguageModel, $projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostAsyncWithHttpInfo
     *
     * Recreate the set of TMs plugged into the project.  A separate set of TMs is created for each target language.
     *
     * @param  \SmartCat\Model\TranslationMemoriesForLanguageModel[] $translationMemoriesForLanguageModel Collections of languages and their respective TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostAsyncWithHttpInfo($translationMemoriesForLanguageModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostRequest($translationMemoriesForLanguageModel, $projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'
     *
     * @param  \SmartCat\Model\TranslationMemoriesForLanguageModel[] $translationMemoriesForLanguageModel Collections of languages and their respective TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPostRequest($translationMemoriesForLanguageModel, $projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'][0])
    {

        // verify the required parameter 'translationMemoriesForLanguageModel' is set
        if ($translationMemoriesForLanguageModel === null || (is_array($translationMemoriesForLanguageModel) && count($translationMemoriesForLanguageModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $translationMemoriesForLanguageModel when calling apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdTranslationmemoriesBylanguagesPost'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/translationmemories/bylanguages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($translationMemoriesForLanguageModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($translationMemoriesForLanguageModel));
            } else {
                $httpBody = $translationMemoriesForLanguageModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesGet
     *
     * Receive a list of the TMs plugged into the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ProjectTranslationMemoryModel[]
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesGet($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'][0])
    {
        list($response) = $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesGetWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesGetWithHttpInfo
     *
     * Receive a list of the TMs plugged into the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ProjectTranslationMemoryModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesGetWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesGetRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ProjectTranslationMemoryModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ProjectTranslationMemoryModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ProjectTranslationMemoryModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ProjectTranslationMemoryModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ProjectTranslationMemoryModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesGetAsync
     *
     * Receive a list of the TMs plugged into the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesGetAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesGetAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesGetAsyncWithHttpInfo
     *
     * Receive a list of the TMs plugged into the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesGetAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'][0])
    {
        $returnType = '\SmartCat\Model\ProjectTranslationMemoryModel[]';
        $request = $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesGetRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesGetRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdTranslationmemoriesGet'
            );
        }


        $resourcePath = '/api/integration/v1/project/{projectId}/translationmemories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesPost
     *
     * Recreate the set of TMs plugged into the project.  The set of TMs is identical for all target languages of the project.
     *
     * @param  \SmartCat\Model\TranslationMemoryForProjectModel[] $translationMemoryForProjectModel Collection of TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactSourceLanguageMatch Specifies whether exact matches in the source language are required (the default is false) (optional, default to false)
     * @param  bool $onlyExactTargetLanguageMatch Specifies whether exact matches in the target language are required (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesPost($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch = false, $onlyExactTargetLanguageMatch = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'][0])
    {
        $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesPostWithHttpInfo($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch, $onlyExactTargetLanguageMatch, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesPostWithHttpInfo
     *
     * Recreate the set of TMs plugged into the project.  The set of TMs is identical for all target languages of the project.
     *
     * @param  \SmartCat\Model\TranslationMemoryForProjectModel[] $translationMemoryForProjectModel Collection of TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactSourceLanguageMatch Specifies whether exact matches in the source language are required (the default is false) (optional, default to false)
     * @param  bool $onlyExactTargetLanguageMatch Specifies whether exact matches in the target language are required (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesPostWithHttpInfo($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch = false, $onlyExactTargetLanguageMatch = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'][0])
    {
        $request = $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesPostRequest($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch, $onlyExactTargetLanguageMatch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesPostAsync
     *
     * Recreate the set of TMs plugged into the project.  The set of TMs is identical for all target languages of the project.
     *
     * @param  \SmartCat\Model\TranslationMemoryForProjectModel[] $translationMemoryForProjectModel Collection of TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactSourceLanguageMatch Specifies whether exact matches in the source language are required (the default is false) (optional, default to false)
     * @param  bool $onlyExactTargetLanguageMatch Specifies whether exact matches in the target language are required (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesPostAsync($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch = false, $onlyExactTargetLanguageMatch = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'][0])
    {
        return $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesPostAsyncWithHttpInfo($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch, $onlyExactTargetLanguageMatch, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectProjectIdTranslationmemoriesPostAsyncWithHttpInfo
     *
     * Recreate the set of TMs plugged into the project.  The set of TMs is identical for all target languages of the project.
     *
     * @param  \SmartCat\Model\TranslationMemoryForProjectModel[] $translationMemoryForProjectModel Collection of TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactSourceLanguageMatch Specifies whether exact matches in the source language are required (the default is false) (optional, default to false)
     * @param  bool $onlyExactTargetLanguageMatch Specifies whether exact matches in the target language are required (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesPostAsyncWithHttpInfo($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch = false, $onlyExactTargetLanguageMatch = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectProjectIdTranslationmemoriesPostRequest($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch, $onlyExactTargetLanguageMatch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'
     *
     * @param  \SmartCat\Model\TranslationMemoryForProjectModel[] $translationMemoryForProjectModel Collection of TMs (required)
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactSourceLanguageMatch Specifies whether exact matches in the source language are required (the default is false) (optional, default to false)
     * @param  bool $onlyExactTargetLanguageMatch Specifies whether exact matches in the target language are required (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectProjectIdTranslationmemoriesPostRequest($translationMemoryForProjectModel, $projectId, $onlyExactSourceLanguageMatch = false, $onlyExactTargetLanguageMatch = false, string $contentType = self::contentTypes['apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'][0])
    {

        // verify the required parameter 'translationMemoryForProjectModel' is set
        if ($translationMemoryForProjectModel === null || (is_array($translationMemoryForProjectModel) && count($translationMemoryForProjectModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $translationMemoryForProjectModel when calling apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectProjectIdTranslationmemoriesPost'
            );
        }




        $resourcePath = '/api/integration/v1/project/{projectId}/translationmemories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onlyExactSourceLanguageMatch,
            'onlyExactSourceLanguageMatch', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onlyExactTargetLanguageMatch,
            'onlyExactTargetLanguageMatch', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($translationMemoryForProjectModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($translationMemoryForProjectModel));
            } else {
                $httpBody = $translationMemoryForProjectModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV1ProjectRestorePost
     *
     * Restore the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectRestorePost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV1ProjectRestorePost($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectRestorePost'][0])
    {
        $this->apiIntegrationV1ProjectRestorePostWithHttpInfo($projectId, $contentType);
    }

    /**
     * Operation apiIntegrationV1ProjectRestorePostWithHttpInfo
     *
     * Restore the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectRestorePost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV1ProjectRestorePostWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectRestorePost'][0])
    {
        $request = $this->apiIntegrationV1ProjectRestorePostRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV1ProjectRestorePostAsync
     *
     * Restore the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectRestorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectRestorePostAsync($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectRestorePost'][0])
    {
        return $this->apiIntegrationV1ProjectRestorePostAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV1ProjectRestorePostAsyncWithHttpInfo
     *
     * Restore the project
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectRestorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV1ProjectRestorePostAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectRestorePost'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV1ProjectRestorePostRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV1ProjectRestorePost'
     *
     * @param  string $projectId Project ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV1ProjectRestorePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV1ProjectRestorePostRequest($projectId, string $contentType = self::contentTypes['apiIntegrationV1ProjectRestorePost'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV1ProjectRestorePost'
            );
        }


        $resourcePath = '/api/integration/v1/project/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectId,
            'projectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV2ProjectListGet
     *
     * Fetch the list of account projects
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  string[] $clientIds Comma-separated client ID (optional)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectListGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SmartCat\Model\ProjectModel[]
     */
    public function apiIntegrationV2ProjectListGet($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $clientIds = null, $offset = 0, $limit = 100, string $contentType = self::contentTypes['apiIntegrationV2ProjectListGet'][0])
    {
        list($response) = $this->apiIntegrationV2ProjectListGetWithHttpInfo($createdByUserId, $assignedToUserId, $projectName, $externalTag, $clientIds, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV2ProjectListGetWithHttpInfo
     *
     * Fetch the list of account projects
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  string[] $clientIds Comma-separated client ID (optional)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectListGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SmartCat\Model\ProjectModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV2ProjectListGetWithHttpInfo($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $clientIds = null, $offset = 0, $limit = 100, string $contentType = self::contentTypes['apiIntegrationV2ProjectListGet'][0])
    {
        $request = $this->apiIntegrationV2ProjectListGetRequest($createdByUserId, $assignedToUserId, $projectName, $externalTag, $clientIds, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SmartCat\Model\ProjectModel[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SmartCat\Model\ProjectModel[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SmartCat\Model\ProjectModel[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SmartCat\Model\ProjectModel[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SmartCat\Model\ProjectModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV2ProjectListGetAsync
     *
     * Fetch the list of account projects
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  string[] $clientIds Comma-separated client ID (optional)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectListGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV2ProjectListGetAsync($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $clientIds = null, $offset = 0, $limit = 100, string $contentType = self::contentTypes['apiIntegrationV2ProjectListGet'][0])
    {
        return $this->apiIntegrationV2ProjectListGetAsyncWithHttpInfo($createdByUserId, $assignedToUserId, $projectName, $externalTag, $clientIds, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV2ProjectListGetAsyncWithHttpInfo
     *
     * Fetch the list of account projects
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  string[] $clientIds Comma-separated client ID (optional)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectListGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV2ProjectListGetAsyncWithHttpInfo($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $clientIds = null, $offset = 0, $limit = 100, string $contentType = self::contentTypes['apiIntegrationV2ProjectListGet'][0])
    {
        $returnType = '\SmartCat\Model\ProjectModel[]';
        $request = $this->apiIntegrationV2ProjectListGetRequest($createdByUserId, $assignedToUserId, $projectName, $externalTag, $clientIds, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV2ProjectListGet'
     *
     * @param  string $createdByUserId ID of the user who created the project (optional)
     * @param  string $assignedToUserId User ID for filtering by assignment (optional)
     * @param  string $projectName Partial project name (optional)
     * @param  string $externalTag Partial external tag of the project (optional)
     * @param  string[] $clientIds Comma-separated client ID (optional)
     * @param  int $offset Number of skipped items (optional, default to 0)
     * @param  int $limit Maximum returned items (not more than 100) (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectListGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV2ProjectListGetRequest($createdByUserId = null, $assignedToUserId = null, $projectName = null, $externalTag = null, $clientIds = null, $offset = 0, $limit = 100, string $contentType = self::contentTypes['apiIntegrationV2ProjectListGet'][0])
    {









        $resourcePath = '/api/integration/v2/project/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $createdByUserId,
            'createdByUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assignedToUserId,
            'assignedToUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $projectName,
            'projectName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $externalTag,
            'externalTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clientIds,
            'clientIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdExportPost
     *
     * Run export from Software Localization Project
     *
     * @param  string $projectId Project ID (required)
     * @param  \SmartCat\Model\ExportKeysFromSoftwareLocalizationProjectModel $exportKeysFromSoftwareLocalizationProjectModel Export keys model (optional)
     * @param  string $collections Comma-separated collections list to export (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $languages Comma-separated list of languages to export (optional, all target languages by default) (optional)
     * @param  ExportingDocumentFormat $format Export format (optional, JSON by default) (optional)
     * @param  string $pathSeparator Path separator string (optional)  When exporting \&quot;structured-json\&quot; and \&quot;structured-yaml\&quot; file formats,  this separator string will be used to split the key into multiple parts and construct the tree structure. (optional)
     * @param  ExportingSegmentCompletionState $completionState Minimal key completion state (optional)  Specifies the state in which any key (segment) must be in order to be exported. (optional)
     * @param  bool $fallbackToDefaultLanguage Return default language values instead of incomplete translations (default) (optional)
     * @param  bool $exportIncompleteAsBlank Export blank values when no translation is ready (optional)
     * @param  bool $skipIncompleteKeys Do not export keys that have no translations (will be used as a default for the \&quot;android-xml\&quot; export file type) (optional)
     * @param  string $outputFilePathTemplate Output file path template (optional)  Specifies how to name the output file (when exporting multiple languages at once)  A reasonable default value will be used depending on the chosen file format  Defaults:  - \&quot;strings-{LANGUAGE}.json\&quot; will be used with the JSON file format  - \&quot;strings-{LANGUAGE}.yaml\&quot; with the yaml file format  - \&quot;{LOCALE:IOS}.lproj/values.strings\&quot; will be used with the ios-strings file format  - \&quot;src/main/res/values-{LOCALE:ANDROID}/strings.xml\&quot; will be used with the android-xml file format (optional)
     * @param  bool $includeDefaultLanguage Specify if the default language should be included in the export (optional)
     * @param  bool $zip Force export to a ZIP archive, even for a single file (optional)
     * @param  \DateTime $modifiedSince Export keys that were changed after the datetime (optional)
     * @param  string $labels Comma-separated list of labels to export keys that are marked with labels (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function apiIntegrationV2ProjectProjectIdExportPost($projectId, $exportKeysFromSoftwareLocalizationProjectModel = null, $collections = null, $languages = null, $format = null, $pathSeparator = null, $completionState = null, $fallbackToDefaultLanguage = null, $exportIncompleteAsBlank = null, $skipIncompleteKeys = null, $outputFilePathTemplate = null, $includeDefaultLanguage = null, $zip = null, $modifiedSince = null, $labels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'][0])
    {
        list($response) = $this->apiIntegrationV2ProjectProjectIdExportPostWithHttpInfo($projectId, $exportKeysFromSoftwareLocalizationProjectModel, $collections, $languages, $format, $pathSeparator, $completionState, $fallbackToDefaultLanguage, $exportIncompleteAsBlank, $skipIncompleteKeys, $outputFilePathTemplate, $includeDefaultLanguage, $zip, $modifiedSince, $labels, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdExportPostWithHttpInfo
     *
     * Run export from Software Localization Project
     *
     * @param  string $projectId Project ID (required)
     * @param  \SmartCat\Model\ExportKeysFromSoftwareLocalizationProjectModel $exportKeysFromSoftwareLocalizationProjectModel Export keys model (optional)
     * @param  string $collections Comma-separated collections list to export (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $languages Comma-separated list of languages to export (optional, all target languages by default) (optional)
     * @param  ExportingDocumentFormat $format Export format (optional, JSON by default) (optional)
     * @param  string $pathSeparator Path separator string (optional)  When exporting \&quot;structured-json\&quot; and \&quot;structured-yaml\&quot; file formats,  this separator string will be used to split the key into multiple parts and construct the tree structure. (optional)
     * @param  ExportingSegmentCompletionState $completionState Minimal key completion state (optional)  Specifies the state in which any key (segment) must be in order to be exported. (optional)
     * @param  bool $fallbackToDefaultLanguage Return default language values instead of incomplete translations (default) (optional)
     * @param  bool $exportIncompleteAsBlank Export blank values when no translation is ready (optional)
     * @param  bool $skipIncompleteKeys Do not export keys that have no translations (will be used as a default for the \&quot;android-xml\&quot; export file type) (optional)
     * @param  string $outputFilePathTemplate Output file path template (optional)  Specifies how to name the output file (when exporting multiple languages at once)  A reasonable default value will be used depending on the chosen file format  Defaults:  - \&quot;strings-{LANGUAGE}.json\&quot; will be used with the JSON file format  - \&quot;strings-{LANGUAGE}.yaml\&quot; with the yaml file format  - \&quot;{LOCALE:IOS}.lproj/values.strings\&quot; will be used with the ios-strings file format  - \&quot;src/main/res/values-{LOCALE:ANDROID}/strings.xml\&quot; will be used with the android-xml file format (optional)
     * @param  bool $includeDefaultLanguage Specify if the default language should be included in the export (optional)
     * @param  bool $zip Force export to a ZIP archive, even for a single file (optional)
     * @param  \DateTime $modifiedSince Export keys that were changed after the datetime (optional)
     * @param  string $labels Comma-separated list of labels to export keys that are marked with labels (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV2ProjectProjectIdExportPostWithHttpInfo($projectId, $exportKeysFromSoftwareLocalizationProjectModel = null, $collections = null, $languages = null, $format = null, $pathSeparator = null, $completionState = null, $fallbackToDefaultLanguage = null, $exportIncompleteAsBlank = null, $skipIncompleteKeys = null, $outputFilePathTemplate = null, $includeDefaultLanguage = null, $zip = null, $modifiedSince = null, $labels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'][0])
    {
        $request = $this->apiIntegrationV2ProjectProjectIdExportPostRequest($projectId, $exportKeysFromSoftwareLocalizationProjectModel, $collections, $languages, $format, $pathSeparator, $completionState, $fallbackToDefaultLanguage, $exportIncompleteAsBlank, $skipIncompleteKeys, $outputFilePathTemplate, $includeDefaultLanguage, $zip, $modifiedSince, $labels, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdExportPostAsync
     *
     * Run export from Software Localization Project
     *
     * @param  string $projectId Project ID (required)
     * @param  \SmartCat\Model\ExportKeysFromSoftwareLocalizationProjectModel $exportKeysFromSoftwareLocalizationProjectModel Export keys model (optional)
     * @param  string $collections Comma-separated collections list to export (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $languages Comma-separated list of languages to export (optional, all target languages by default) (optional)
     * @param  ExportingDocumentFormat $format Export format (optional, JSON by default) (optional)
     * @param  string $pathSeparator Path separator string (optional)  When exporting \&quot;structured-json\&quot; and \&quot;structured-yaml\&quot; file formats,  this separator string will be used to split the key into multiple parts and construct the tree structure. (optional)
     * @param  ExportingSegmentCompletionState $completionState Minimal key completion state (optional)  Specifies the state in which any key (segment) must be in order to be exported. (optional)
     * @param  bool $fallbackToDefaultLanguage Return default language values instead of incomplete translations (default) (optional)
     * @param  bool $exportIncompleteAsBlank Export blank values when no translation is ready (optional)
     * @param  bool $skipIncompleteKeys Do not export keys that have no translations (will be used as a default for the \&quot;android-xml\&quot; export file type) (optional)
     * @param  string $outputFilePathTemplate Output file path template (optional)  Specifies how to name the output file (when exporting multiple languages at once)  A reasonable default value will be used depending on the chosen file format  Defaults:  - \&quot;strings-{LANGUAGE}.json\&quot; will be used with the JSON file format  - \&quot;strings-{LANGUAGE}.yaml\&quot; with the yaml file format  - \&quot;{LOCALE:IOS}.lproj/values.strings\&quot; will be used with the ios-strings file format  - \&quot;src/main/res/values-{LOCALE:ANDROID}/strings.xml\&quot; will be used with the android-xml file format (optional)
     * @param  bool $includeDefaultLanguage Specify if the default language should be included in the export (optional)
     * @param  bool $zip Force export to a ZIP archive, even for a single file (optional)
     * @param  \DateTime $modifiedSince Export keys that were changed after the datetime (optional)
     * @param  string $labels Comma-separated list of labels to export keys that are marked with labels (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV2ProjectProjectIdExportPostAsync($projectId, $exportKeysFromSoftwareLocalizationProjectModel = null, $collections = null, $languages = null, $format = null, $pathSeparator = null, $completionState = null, $fallbackToDefaultLanguage = null, $exportIncompleteAsBlank = null, $skipIncompleteKeys = null, $outputFilePathTemplate = null, $includeDefaultLanguage = null, $zip = null, $modifiedSince = null, $labels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'][0])
    {
        return $this->apiIntegrationV2ProjectProjectIdExportPostAsyncWithHttpInfo($projectId, $exportKeysFromSoftwareLocalizationProjectModel, $collections, $languages, $format, $pathSeparator, $completionState, $fallbackToDefaultLanguage, $exportIncompleteAsBlank, $skipIncompleteKeys, $outputFilePathTemplate, $includeDefaultLanguage, $zip, $modifiedSince, $labels, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdExportPostAsyncWithHttpInfo
     *
     * Run export from Software Localization Project
     *
     * @param  string $projectId Project ID (required)
     * @param  \SmartCat\Model\ExportKeysFromSoftwareLocalizationProjectModel $exportKeysFromSoftwareLocalizationProjectModel Export keys model (optional)
     * @param  string $collections Comma-separated collections list to export (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $languages Comma-separated list of languages to export (optional, all target languages by default) (optional)
     * @param  ExportingDocumentFormat $format Export format (optional, JSON by default) (optional)
     * @param  string $pathSeparator Path separator string (optional)  When exporting \&quot;structured-json\&quot; and \&quot;structured-yaml\&quot; file formats,  this separator string will be used to split the key into multiple parts and construct the tree structure. (optional)
     * @param  ExportingSegmentCompletionState $completionState Minimal key completion state (optional)  Specifies the state in which any key (segment) must be in order to be exported. (optional)
     * @param  bool $fallbackToDefaultLanguage Return default language values instead of incomplete translations (default) (optional)
     * @param  bool $exportIncompleteAsBlank Export blank values when no translation is ready (optional)
     * @param  bool $skipIncompleteKeys Do not export keys that have no translations (will be used as a default for the \&quot;android-xml\&quot; export file type) (optional)
     * @param  string $outputFilePathTemplate Output file path template (optional)  Specifies how to name the output file (when exporting multiple languages at once)  A reasonable default value will be used depending on the chosen file format  Defaults:  - \&quot;strings-{LANGUAGE}.json\&quot; will be used with the JSON file format  - \&quot;strings-{LANGUAGE}.yaml\&quot; with the yaml file format  - \&quot;{LOCALE:IOS}.lproj/values.strings\&quot; will be used with the ios-strings file format  - \&quot;src/main/res/values-{LOCALE:ANDROID}/strings.xml\&quot; will be used with the android-xml file format (optional)
     * @param  bool $includeDefaultLanguage Specify if the default language should be included in the export (optional)
     * @param  bool $zip Force export to a ZIP archive, even for a single file (optional)
     * @param  \DateTime $modifiedSince Export keys that were changed after the datetime (optional)
     * @param  string $labels Comma-separated list of labels to export keys that are marked with labels (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV2ProjectProjectIdExportPostAsyncWithHttpInfo($projectId, $exportKeysFromSoftwareLocalizationProjectModel = null, $collections = null, $languages = null, $format = null, $pathSeparator = null, $completionState = null, $fallbackToDefaultLanguage = null, $exportIncompleteAsBlank = null, $skipIncompleteKeys = null, $outputFilePathTemplate = null, $includeDefaultLanguage = null, $zip = null, $modifiedSince = null, $labels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'][0])
    {
        $returnType = 'string';
        $request = $this->apiIntegrationV2ProjectProjectIdExportPostRequest($projectId, $exportKeysFromSoftwareLocalizationProjectModel, $collections, $languages, $format, $pathSeparator, $completionState, $fallbackToDefaultLanguage, $exportIncompleteAsBlank, $skipIncompleteKeys, $outputFilePathTemplate, $includeDefaultLanguage, $zip, $modifiedSince, $labels, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV2ProjectProjectIdExportPost'
     *
     * @param  string $projectId Project ID (required)
     * @param  \SmartCat\Model\ExportKeysFromSoftwareLocalizationProjectModel $exportKeysFromSoftwareLocalizationProjectModel Export keys model (optional)
     * @param  string $collections Comma-separated collections list to export (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $languages Comma-separated list of languages to export (optional, all target languages by default) (optional)
     * @param  ExportingDocumentFormat $format Export format (optional, JSON by default) (optional)
     * @param  string $pathSeparator Path separator string (optional)  When exporting \&quot;structured-json\&quot; and \&quot;structured-yaml\&quot; file formats,  this separator string will be used to split the key into multiple parts and construct the tree structure. (optional)
     * @param  ExportingSegmentCompletionState $completionState Minimal key completion state (optional)  Specifies the state in which any key (segment) must be in order to be exported. (optional)
     * @param  bool $fallbackToDefaultLanguage Return default language values instead of incomplete translations (default) (optional)
     * @param  bool $exportIncompleteAsBlank Export blank values when no translation is ready (optional)
     * @param  bool $skipIncompleteKeys Do not export keys that have no translations (will be used as a default for the \&quot;android-xml\&quot; export file type) (optional)
     * @param  string $outputFilePathTemplate Output file path template (optional)  Specifies how to name the output file (when exporting multiple languages at once)  A reasonable default value will be used depending on the chosen file format  Defaults:  - \&quot;strings-{LANGUAGE}.json\&quot; will be used with the JSON file format  - \&quot;strings-{LANGUAGE}.yaml\&quot; with the yaml file format  - \&quot;{LOCALE:IOS}.lproj/values.strings\&quot; will be used with the ios-strings file format  - \&quot;src/main/res/values-{LOCALE:ANDROID}/strings.xml\&quot; will be used with the android-xml file format (optional)
     * @param  bool $includeDefaultLanguage Specify if the default language should be included in the export (optional)
     * @param  bool $zip Force export to a ZIP archive, even for a single file (optional)
     * @param  \DateTime $modifiedSince Export keys that were changed after the datetime (optional)
     * @param  string $labels Comma-separated list of labels to export keys that are marked with labels (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV2ProjectProjectIdExportPostRequest($projectId, $exportKeysFromSoftwareLocalizationProjectModel = null, $collections = null, $languages = null, $format = null, $pathSeparator = null, $completionState = null, $fallbackToDefaultLanguage = null, $exportIncompleteAsBlank = null, $skipIncompleteKeys = null, $outputFilePathTemplate = null, $includeDefaultLanguage = null, $zip = null, $modifiedSince = null, $labels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdExportPost'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV2ProjectProjectIdExportPost'
            );
        }
















        $resourcePath = '/api/integration/v2/project/{projectId}/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $collections,
            'collections', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $languages,
            'languages', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ExportingDocumentFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pathSeparator,
            'path-separator', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $completionState,
            'completion-state', // param base name
            'ExportingSegmentCompletionState', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fallbackToDefaultLanguage,
            'fallback-to-default-language', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exportIncompleteAsBlank,
            'export-incomplete-as-blank', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skipIncompleteKeys,
            'skip-incomplete-keys', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $outputFilePathTemplate,
            'output-file-path-template', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $includeDefaultLanguage,
            'include-default-language', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $zip,
            'zip', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modifiedSince,
            'modified-since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $labels,
            'labels', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($exportKeysFromSoftwareLocalizationProjectModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($exportKeysFromSoftwareLocalizationProjectModel));
            } else {
                $httpBody = $exportKeysFromSoftwareLocalizationProjectModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdImportPost
     *
     * Import keys and values from files into the Software Localization Project
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files for import (required)
     * @param  string $projectId Project identifier (required)
     * @param  string $collection Target collection (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $language Language of the imported files (optional)
     * @param  string $targetLanguages Comma separated list of target languages  (optional, all target languages of the project by default, can only be specified when importing the source) (optional)
     * @param  ExportingDocumentFormat $format Specifies the file format used to import the file (optional).  Smartcat will try to identify the file format from its extension. (optional)
     * @param  string $labels Comma-separated labels that will be attached to the created/updated segments (even if the text is not changed) (optional)
     * @param  string $pathSeparator Path separator string (optional) (optional)
     * @param  bool $skipConflictingValues Specifies how to deal with situations when the same key has a different  value in the imported file and in Smartcat - keeps the value in Smartcat by default (optional)
     * @param  bool $overwriteConflictingValues When the same key has a different value in the imported file and in Smartcat - use the value from the file (optional)
     * @param  bool $autoFileLabels Should Smartcat automatically create labels after file names? (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function apiIntegrationV2ProjectProjectIdImportPost($uploadedFile, $projectId, $collection = null, $language = null, $targetLanguages = null, $format = null, $labels = null, $pathSeparator = null, $skipConflictingValues = null, $overwriteConflictingValues = null, $autoFileLabels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'][0])
    {
        list($response) = $this->apiIntegrationV2ProjectProjectIdImportPostWithHttpInfo($uploadedFile, $projectId, $collection, $language, $targetLanguages, $format, $labels, $pathSeparator, $skipConflictingValues, $overwriteConflictingValues, $autoFileLabels, $contentType);
        return $response;
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdImportPostWithHttpInfo
     *
     * Import keys and values from files into the Software Localization Project
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files for import (required)
     * @param  string $projectId Project identifier (required)
     * @param  string $collection Target collection (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $language Language of the imported files (optional)
     * @param  string $targetLanguages Comma separated list of target languages  (optional, all target languages of the project by default, can only be specified when importing the source) (optional)
     * @param  ExportingDocumentFormat $format Specifies the file format used to import the file (optional).  Smartcat will try to identify the file format from its extension. (optional)
     * @param  string $labels Comma-separated labels that will be attached to the created/updated segments (even if the text is not changed) (optional)
     * @param  string $pathSeparator Path separator string (optional) (optional)
     * @param  bool $skipConflictingValues Specifies how to deal with situations when the same key has a different  value in the imported file and in Smartcat - keeps the value in Smartcat by default (optional)
     * @param  bool $overwriteConflictingValues When the same key has a different value in the imported file and in Smartcat - use the value from the file (optional)
     * @param  bool $autoFileLabels Should Smartcat automatically create labels after file names? (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV2ProjectProjectIdImportPostWithHttpInfo($uploadedFile, $projectId, $collection = null, $language = null, $targetLanguages = null, $format = null, $labels = null, $pathSeparator = null, $skipConflictingValues = null, $overwriteConflictingValues = null, $autoFileLabels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'][0])
    {
        $request = $this->apiIntegrationV2ProjectProjectIdImportPostRequest($uploadedFile, $projectId, $collection, $language, $targetLanguages, $format, $labels, $pathSeparator, $skipConflictingValues, $overwriteConflictingValues, $autoFileLabels, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdImportPostAsync
     *
     * Import keys and values from files into the Software Localization Project
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files for import (required)
     * @param  string $projectId Project identifier (required)
     * @param  string $collection Target collection (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $language Language of the imported files (optional)
     * @param  string $targetLanguages Comma separated list of target languages  (optional, all target languages of the project by default, can only be specified when importing the source) (optional)
     * @param  ExportingDocumentFormat $format Specifies the file format used to import the file (optional).  Smartcat will try to identify the file format from its extension. (optional)
     * @param  string $labels Comma-separated labels that will be attached to the created/updated segments (even if the text is not changed) (optional)
     * @param  string $pathSeparator Path separator string (optional) (optional)
     * @param  bool $skipConflictingValues Specifies how to deal with situations when the same key has a different  value in the imported file and in Smartcat - keeps the value in Smartcat by default (optional)
     * @param  bool $overwriteConflictingValues When the same key has a different value in the imported file and in Smartcat - use the value from the file (optional)
     * @param  bool $autoFileLabels Should Smartcat automatically create labels after file names? (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV2ProjectProjectIdImportPostAsync($uploadedFile, $projectId, $collection = null, $language = null, $targetLanguages = null, $format = null, $labels = null, $pathSeparator = null, $skipConflictingValues = null, $overwriteConflictingValues = null, $autoFileLabels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'][0])
    {
        return $this->apiIntegrationV2ProjectProjectIdImportPostAsyncWithHttpInfo($uploadedFile, $projectId, $collection, $language, $targetLanguages, $format, $labels, $pathSeparator, $skipConflictingValues, $overwriteConflictingValues, $autoFileLabels, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdImportPostAsyncWithHttpInfo
     *
     * Import keys and values from files into the Software Localization Project
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files for import (required)
     * @param  string $projectId Project identifier (required)
     * @param  string $collection Target collection (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $language Language of the imported files (optional)
     * @param  string $targetLanguages Comma separated list of target languages  (optional, all target languages of the project by default, can only be specified when importing the source) (optional)
     * @param  ExportingDocumentFormat $format Specifies the file format used to import the file (optional).  Smartcat will try to identify the file format from its extension. (optional)
     * @param  string $labels Comma-separated labels that will be attached to the created/updated segments (even if the text is not changed) (optional)
     * @param  string $pathSeparator Path separator string (optional) (optional)
     * @param  bool $skipConflictingValues Specifies how to deal with situations when the same key has a different  value in the imported file and in Smartcat - keeps the value in Smartcat by default (optional)
     * @param  bool $overwriteConflictingValues When the same key has a different value in the imported file and in Smartcat - use the value from the file (optional)
     * @param  bool $autoFileLabels Should Smartcat automatically create labels after file names? (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV2ProjectProjectIdImportPostAsyncWithHttpInfo($uploadedFile, $projectId, $collection = null, $language = null, $targetLanguages = null, $format = null, $labels = null, $pathSeparator = null, $skipConflictingValues = null, $overwriteConflictingValues = null, $autoFileLabels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'][0])
    {
        $returnType = 'string';
        $request = $this->apiIntegrationV2ProjectProjectIdImportPostRequest($uploadedFile, $projectId, $collection, $language, $targetLanguages, $format, $labels, $pathSeparator, $skipConflictingValues, $overwriteConflictingValues, $autoFileLabels, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV2ProjectProjectIdImportPost'
     *
     * @param  \SmartCat\Model\UploadedFile[] $uploadedFile Files for import (required)
     * @param  string $projectId Project identifier (required)
     * @param  string $collection Target collection (optional, \&quot;main\&quot; as default) (optional)
     * @param  string $language Language of the imported files (optional)
     * @param  string $targetLanguages Comma separated list of target languages  (optional, all target languages of the project by default, can only be specified when importing the source) (optional)
     * @param  ExportingDocumentFormat $format Specifies the file format used to import the file (optional).  Smartcat will try to identify the file format from its extension. (optional)
     * @param  string $labels Comma-separated labels that will be attached to the created/updated segments (even if the text is not changed) (optional)
     * @param  string $pathSeparator Path separator string (optional) (optional)
     * @param  bool $skipConflictingValues Specifies how to deal with situations when the same key has a different  value in the imported file and in Smartcat - keeps the value in Smartcat by default (optional)
     * @param  bool $overwriteConflictingValues When the same key has a different value in the imported file and in Smartcat - use the value from the file (optional)
     * @param  bool $autoFileLabels Should Smartcat automatically create labels after file names? (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV2ProjectProjectIdImportPostRequest($uploadedFile, $projectId, $collection = null, $language = null, $targetLanguages = null, $format = null, $labels = null, $pathSeparator = null, $skipConflictingValues = null, $overwriteConflictingValues = null, $autoFileLabels = null, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdImportPost'][0])
    {

        // verify the required parameter 'uploadedFile' is set
        if ($uploadedFile === null || (is_array($uploadedFile) && count($uploadedFile) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uploadedFile when calling apiIntegrationV2ProjectProjectIdImportPost'
            );
        }

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV2ProjectProjectIdImportPost'
            );
        }











        $resourcePath = '/api/integration/v2/project/{projectId}/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $collection,
            'collection', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $targetLanguages,
            'target-languages', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ExportingDocumentFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $labels,
            'labels', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pathSeparator,
            'path-separator', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skipConflictingValues,
            'skip-conflicting-values', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $overwriteConflictingValues,
            'overwrite-conflicting-values', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $autoFileLabels,
            'auto-file-labels', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($uploadedFile)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($uploadedFile));
            } else {
                $httpBody = $uploadedFile;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdStatisticsGet
     *
     * Fetch project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiIntegrationV2ProjectProjectIdStatisticsGet($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'][0])
    {
        $this->apiIntegrationV2ProjectProjectIdStatisticsGetWithHttpInfo($projectId, $onlyExactMatches, $contentType);
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdStatisticsGetWithHttpInfo
     *
     * Fetch project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \SmartCat\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiIntegrationV2ProjectProjectIdStatisticsGetWithHttpInfo($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'][0])
    {
        $request = $this->apiIntegrationV2ProjectProjectIdStatisticsGetRequest($projectId, $onlyExactMatches, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdStatisticsGetAsync
     *
     * Fetch project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV2ProjectProjectIdStatisticsGetAsync($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'][0])
    {
        return $this->apiIntegrationV2ProjectProjectIdStatisticsGetAsyncWithHttpInfo($projectId, $onlyExactMatches, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiIntegrationV2ProjectProjectIdStatisticsGetAsyncWithHttpInfo
     *
     * Fetch project statistics
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiIntegrationV2ProjectProjectIdStatisticsGetAsyncWithHttpInfo($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'][0])
    {
        $returnType = '';
        $request = $this->apiIntegrationV2ProjectProjectIdStatisticsGetRequest($projectId, $onlyExactMatches, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiIntegrationV2ProjectProjectIdStatisticsGet'
     *
     * @param  string $projectId Project ID (required)
     * @param  bool $onlyExactMatches Specifies whether returning 100% and higher matches will suffice (the default is false) (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiIntegrationV2ProjectProjectIdStatisticsGetRequest($projectId, $onlyExactMatches = false, string $contentType = self::contentTypes['apiIntegrationV2ProjectProjectIdStatisticsGet'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling apiIntegrationV2ProjectProjectIdStatisticsGet'
            );
        }



        $resourcePath = '/api/integration/v2/project/{projectId}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onlyExactMatches,
            'onlyExactMatches', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
